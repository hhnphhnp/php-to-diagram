<?php
/*
 * Copyright (c) 2025 Bloxtor (http://bloxtor.com) and Joao Pinto (http://jplpinto.com)
 * 
 * Multi-licensed: BSD 3-Clause | Apache 2.0 | GNU LGPL v3 | HLNC License (http://bloxtor.com/LICENSE_HLNC.md)
 * Choose one license that best fits your needs.
 *
 * Original PHP to Diagram Repo: https://github.com/a19836/php-to-diagram/
 * Original Bloxtor Repo: https://github.com/a19836/bloxtor
 *
 * YOU ARE NOT AUTHORIZED TO MODIFY OR REMOVE ANY PART OF THIS NOTICE!
 */

class TextSanitizer {
	
	//replace \n inside of double quotes variables, bc prettyPrint escapes the end lines. 
	//Note that $text is a html code with php code inside.
	//This method should be used in the code generated by the PhpParser\PrettyPrinter\Standard->prettyPrint($stmts); See an example in CMSFileHandler::setMethodParamsFromContent
	public static function replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode($text) {
		$text_chars = self::mbStrSplit($text);
		$l = count($text_chars);
		$new_text = "";
		
		for ($i = 0; $i < $l; $i++) {
			$c = $text_chars[$i];
			
			if ($c == "<") {
				$next_char = $i + 1 < $l ? $text_chars[$i + 1] : null;
				
				if ($next_char == "?") { //start of php tag
					$dqo = $sqo = false;
					$sub_text = $c . $next_char;
					
					for ($j = $i + 2; $j < $l; $j++) {
						$sub_c = $text_chars[$j];
						
						if ($sub_c == '"' && !$sqo && !self::isMBCharEscaped($text, $j, $text_chars))
							$dqo = !$dqo;
						else if ($sub_c == "'" && !$dqo && !self::isMBCharEscaped($text, $j, $text_chars))
							$sqo = !$sqo;
						else if ($sub_c == "?" && $j + 1 < $l && $text_chars[$j + 1] == ">" && !$dqo && !$sqo) { //end of php tab
							$sub_text .= $sub_c . $text_chars[$j + 1];
							break;
						}
						else if ($dqo && $sub_c == "n" && self::isMBCharEscaped($text, $j, $text_chars)) { //if escaped end line
							$sub_text = mb_substr($sub_text, 0, -1) . "\n";
							continue 1;
						}
						
						$sub_text .= $sub_c;
					}
					
					$i = $j + 1;
					$c = $sub_text;
				}
			}
			
			$new_text .= $c;
		}
		
		//echo "new_text:$new_text";die();
		//echo "new_text:$text";die();
		return $new_text;
	}
	
	/**
	* replaceIfNotEscaped: replaces a string inside of another string if not escaped, this is, repace $to_replace by $to_replacement in $text if $to_replace not escaped. Return the new string with the values replaced.
	*/
	//Used in this class and in lib/workflow/task/programming/createform/WorkFlowTaskImpl.php and lib/.../CMSFileHandler.php
	public static function replaceIfNotEscaped($to_replace, $replacement, $text) {
		if ($text && $to_replace) {
			$new_text = "";
			$text_chars = self::mbStrSplit($text);
			$to_replace_chars = self::mbStrSplit($to_replace);
			$l = count($text_chars);
			$trl = count($to_replace_chars);
			
			for ($i = 0; $i < $l; $i++) {
				$c = $text_chars[$i];
				
				if ($trl > 0 && $c == $to_replace_chars[0]) {
					$diff = $trl == 1 ? null : array_diff_assoc(array_slice($text_chars, $i, $trl), $to_replace_chars);
					
					if (empty($diff) && !self::isMBCharEscaped($text, $i, $text_chars)) {
						$new_text .= $replacement;
						$i += $trl - 1;
						
						continue 1;
					}
				}
				
				$new_text .= $c;
			}
			
			return $new_text;
		}
		
		return $text;
	}
	
	/**
	* stripCSlashes: strip all slashes for all characters inside of $chars
	* Note that the stripcslashes and stripslashes have a diferent behaviour. The stripcslashes removes slashes for double quotes and the stripslashes remove slashes for a bunch of escaped chars. 
	* This method only removes the slashes for a specific chars and if the chars are escaped, this is, if there is "\\'", this method won't remove any slash.
	*/
	public static function stripCSlashes($text, $chars) {
		$chars = is_array($chars) ? $chars : self::mbStrSplit($chars);
		$t = count($chars);
		
		for ($i = 0; $i < $t; $i++) {
			$char = $chars[$i];
			
			if ($char != "\\")
				$text = self::stripCharSlashes($text, $char);
		}
		
		if (array_search("\\", $chars)) 
			$text = self::stripCharSlashes($text, "\\");
		
		return $text;
	}
	
	/**
	* stripCharSlashes: strip all slashes for a specific character
	*/
	public static function stripCharSlashes($text, $char) {
		$text_chars = self::mbStrSplit($text);
		$l = count($text_chars);
		$new_text = "";
		
		for ($i = 0; $i < $l; $i++) {
			$c = $text_chars[$i];
			
			if ($i + 1 < $l && $text_chars[$i + 1] == $char && $c == "\\" && !self::isMBCharEscaped($text, $i, $text_chars))
				$new_text .= "";
			else
				$new_text .= $c;
		}
		
		return $new_text;
	}
	
	/**
	* addCSlashes: add slashes to all characters inside of $chars
	* Note that the addcslashes and addslashes have a diferent behaviour. The addcslashes adds slashes for all double quotes even if they are escaped and the addslashes remove slashes for a bunch of escaped chars. 
	* This method only adds slashes for a specific chars and if the chars are escaped, this is, if there is "\'", this method will add a slash to "\" and another to "'", converting the code to "\\\'". But if there a code like "\\'", this method will convert it to: "\\\'". This means that this code is intelligent.
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/
	public static function addCSlashes($text, $chars, $php_vars_control = false) {
		//error_log("addCSlashes(\$text, $chars, $php_vars_control\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		$chars = is_array($chars) ? $chars : self::mbStrSplit($chars);
		$t = count($chars);
		$add_slash_to_escaped_char = true;
		
		if (array_search("\\", $chars)) {
			$text = self::addCharSlashes($text, "\\", false, $php_vars_control);
			$add_slash_to_escaped_char = false;
		}
		
		for ($i = 0; $i < $t; $i++) {
			$char = $chars[$i];
			
			if ($char != "\\")
				$text = self::addCharSlashes($text, $char, $add_slash_to_escaped_char, $php_vars_control);
		}
		
		return $text;
	}
	
	/**
	* addCharSlashes: add slashes for a specific character
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/
	public static function addCharSlashes($text, $char, $add_slash_to_escaped_char = true, $php_vars_control = false) {
		$text_chars = self::mbStrSplit($text);
		
		if ($php_vars_control && (mb_strpos($text, '{$') !== false || mb_strpos($text, '${') !== false))
			return self::addCharSlashesWithPHPVarsControl($text, $char, $add_slash_to_escaped_char, $text_chars);
		
		$l = count($text_chars);
		$new_text = "";
		
		for ($i = 0; $i < $l; $i++) {
			$c = $text_chars[$i];
			
			if ($c == $char)
				$new_text .= "\\" . ($add_slash_to_escaped_char && self::isMBCharEscaped($text, $i, $text_chars) ? "\\" : "");
			
			$new_text .= $c;
		}
		
		return $new_text;
	}
	
	/**
	* addCharSlashesWithPHPVarsControl: add slashes for a specific character but only in the text outside of the php vars like ${...} or {$...}
	*
	* 	This is, checks if exists any '{$' or '${' and if yes, doesn't escapes anything inside of the brackets, bc it is a php var that should not be touched.
	* 		example: 
	*			'"' . self::addCharSlashes('this is a simple phrase with double quotes " and the var {$person["name"]}!', '"') . '"'
	*
	* 		When addCharSlashesWithPHPVarsControl is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person["name"]}!"'
	* 		When addCharSlashes is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person[\"name\"]}!"'
	*			...which will return a php error, bc what is inside of {$...} will be executed first in php!
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*/
	public static function addCharSlashesWithPHPVarsControl($text, $char, $add_slash_to_escaped_char = true, $text_chars = null) {
		$text_chars = $text_chars ? $text_chars : self::mbStrSplit($text);
		$l = count($text_chars);
		$is_var = 0;
		$new_text = "";
		
		for ($i = 0; $i < $l; $i++) {
			$c = $text_chars[$i];
			
			if (
				$c == '$' && 
				(
					($i > 0 && $text_chars[$i - 1] == "{") 
					|| 
					($i + 1 < $l && $text_chars[$i + 1] == "{")
				) && 
				!self::isMBCharEscaped($text, $i, $text_chars)
			) //{$...} or ${...}
				$is_var++;
			else if ($is_var && $c == "}")
				$is_var--;
			else if (!$is_var && $c == $char)
				$new_text .= "\\" . ($add_slash_to_escaped_char && self::isMBCharEscaped($text, $i, $text_chars) ? "\\" : "");
			
			$new_text .= $c;
		}
		
		return $new_text;
	}
	
	/**
	* mbStrSplit: returns the multibyte character list of a string. 
	* This function splits a multibyte string into an array of characters. Comparable to str_split().
	* A (simpler) way to extract all characters from a UTF-8 string to array.
	*/
	public static function mbStrSplit($str) {
		# Split at all position not after the start: ^
		# and not before the end: $
		return function_exists("mb_str_split") ? mb_str_split($str) : preg_split('//u', $str, null, PREG_SPLIT_NO_EMPTY);
	}
	
	/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/
	public static function isCharEscaped($str, $index) {
		$escaped = false;
		
		if (is_numeric($str))
			$str = (string)$str; //bc of php > 7.4 if we use $sql[$i] gives an warning
		
		for ($i = $index - 1; $i >= 0; $i--) {
			if ($str[$i] == "\\")
				$escaped = !$escaped;
			else
				break;
		}
		
		return $escaped;
	}
	
	/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/
	public static function isMBCharEscaped($str, $index, $text_chars = null) {
		$escaped = false;
		$text_chars = $text_chars ? $text_chars : self::mbStrSplit($str);
		
		for ($i = $index - 1; $i >= 0; $i--) {
			if ($text_chars[$i] == "\\")
				$escaped = !$escaped;
			else
				break;
		}
		
		return $escaped;
	}
}	

?>
